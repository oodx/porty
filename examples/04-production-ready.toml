# Production-Ready Configuration
# Comprehensive setup with error handling, logging, and multiple routes

listen_addr = "0.0.0.0"
listen_port = 8080
target_addr = "127.0.0.1"
target_port = 3000
max_connections = 500           # Higher connection limit for production
buffer_size_kb = 16             # Larger buffer for better performance
log_requests = true

# Production API with robust error handling
[[routes]]
name = "production-api"
listen_port = 443
target_addr = "api-cluster.internal"
target_port = 8080
enabled = true
mode = "http"
host = "api.company.com"
log_level = "basic"             # Balanced logging for production
timeout_seconds = 5             # Fast timeout for responsiveness
max_retries = 3                 # Aggressive retries for reliability

# Staging environment with verbose logging
[[routes]]
name = "staging-api"
listen_port = 8443
target_addr = "staging-api.internal"
target_port = 8080
enabled = true
mode = "http"
host = "staging-api.company.com"
log_level = "verbose"           # Detailed logging for debugging
timeout_seconds = 30            # Longer timeout for staging
max_retries = 1                 # Fewer retries in staging

# Load balancer simulation with dynamic routing
[[routes]]
name = "load-balancer"
listen_port = 9090
target_addr = "default-backend.internal"
target_port = 8080
enabled = true
mode = "http"
# No host = accepts any, enables dynamic routing
log_level = "basic"
timeout_seconds = 10
max_retries = 2

# Development proxy with lenient settings
[[routes]]
name = "dev-proxy"
listen_port = 3001
target_addr = "localhost"
target_port = 3000
enabled = true
mode = "http"
log_level = "verbose"           # Full debugging info
timeout_seconds = 60            # Long timeout for debugging
max_retries = 0                 # No retries to see immediate failures

# TCP services (database, cache, etc.)
[[routes]]
name = "redis-proxy"
listen_port = 6380
target_addr = "redis.internal"
target_port = 6379
enabled = true
mode = "tcp"                    # TCP mode for Redis

[[routes]]
name = "postgres-proxy"
listen_port = 5433
target_addr = "postgres.internal"
target_port = 5432
enabled = true
mode = "tcp"                    # TCP mode for PostgreSQL

# Usage Examples:
# ./porty start --config=examples/04-production-ready.toml
#
# Production API:
# curl -H "Host: api.company.com" "https://localhost:443/v1/users"
#
# Dynamic load balancing:
# curl "http://localhost:9090/health?porty_host=backend1.internal&porty_port=8080"
# curl "http://localhost:9090/health?porty_host=backend2.internal&porty_port=8080"
#
# Development with full logging:
# curl "http://localhost:3001/api/debug"
#
# TCP connections:
# redis-cli -p 6380        # Connects to redis.internal:6379
# psql -h localhost -p 5433  # Connects to postgres.internal:5432